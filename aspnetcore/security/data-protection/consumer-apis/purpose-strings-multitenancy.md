---
title: Gerarchia degli scopi e multi-tenant in ASP.NET Core
author: rick-anderson
description: Informazioni sulla gerarchia di stringhe per finalità e sul multi-tenant in relazione alle API di protezione dei dati ASP.NET Core.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 1133d40e7b325d58b3f70e7387494dae36ff8ac9
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/06/2020
ms.locfileid: "78664752"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="a1ccf-103">Gerarchia degli scopi e multi-tenant in ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="a1ccf-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="a1ccf-104">Poiché un `IDataProtector` è anche implicitamente un `IDataProtectionProvider`, gli scopi possono essere concatenati.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="a1ccf-105">In questo senso, `provider.CreateProtector([ "purpose1", "purpose2" ])` equivale a `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="a1ccf-106">Questo consente di eseguire alcune interessanti relazioni gerarchiche tramite il sistema di protezione dei dati.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="a1ccf-107">Nell'esempio precedente di [contoso. Messaging. SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), il componente SecureMessage può chiamare `provider.CreateProtector("Contoso.Messaging.SecureMessage")` una volta in primo piano e memorizzare nella cache il risultato in un campo di `_myProvider` privato.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="a1ccf-108">È quindi possibile creare protezioni future tramite chiamate a `_myProvider.CreateProtector("User: username")`e tali protezioni verranno utilizzate per proteggere i singoli messaggi.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="a1ccf-109">Questa operazione può anche essere capovolta.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-109">This can also be flipped.</span></span> <span data-ttu-id="a1ccf-110">Si consideri una singola applicazione logica che ospita più tenant (un CMS sembra ragionevole) e ogni tenant può essere configurato con il proprio sistema di gestione di autenticazione e stato.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="a1ccf-111">L'applicazione Umbrella dispone di un singolo provider master e chiama `provider.CreateProtector("Tenant 1")` e `provider.CreateProtector("Tenant 2")` per assegnare a ogni tenant una sezione isolata del sistema di protezione dei dati.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="a1ccf-112">I tenant possono quindi derivare le proprie protezioni personalizzate in base alle proprie esigenze, ma indipendentemente dal livello di difficoltà con cui tentano di non creare protezioni che si scontrano con qualsiasi altro tenant nel sistema.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="a1ccf-113">Graficamente, rappresentata come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-113">Graphically, this is represented as below.</span></span>

![Scopi di multi-tenant](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="a1ccf-115">Si presuppone che l'applicazione Umbrella controlli quali API sono disponibili per i singoli tenant e che i tenant non possono eseguire codice arbitrario sul server.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="a1ccf-116">Se un tenant può eseguire codice arbitrario, può eseguire la reflection privata per suddividere le garanzie di isolamento oppure può semplicemente leggere direttamente il materiale della chiave master e derivare tutte le sottochiavi desiderate.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="a1ccf-117">Il sistema di protezione dei dati utilizza effettivamente una sorta di multi-tenant nella configurazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="a1ccf-118">Per impostazione predefinita, il materiale per le chiavi master viene archiviato nella cartella del profilo utente dell'account del processo di lavoro (o nel registro di sistema per le identità del pool di applicazioni IIS).</span><span class="sxs-lookup"><span data-stu-id="a1ccf-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="a1ccf-119">Ma in realtà è abbastanza comune usare un singolo account per eseguire più applicazioni, quindi tutte le applicazioni finiranno con la condivisione del materiale delle chiavi master.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="a1ccf-120">Per risolvere questo problema, il sistema di protezione dei dati inserisce automaticamente un identificatore univoco per applicazione come primo elemento nella catena di scopi generali.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="a1ccf-121">Questo scopo implicito consente di [isolare le singole applicazioni](xref:security/data-protection/configuration/overview#per-application-isolation) l'una dall'altra, trattando in modo efficace ogni applicazione come tenant univoco all'interno del sistema e il processo di creazione della protezione è identico all'immagine precedente.</span><span class="sxs-lookup"><span data-stu-id="a1ccf-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
